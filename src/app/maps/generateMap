export function generateMap(width, height, start, end) {
	// Función para generar un valor aleatorio entre 1 y 10
	function getRandomValue() {
		const num = Math.floor(Math.random() * (10 - 2 + 1)) + 2;
		return num;
	}

	// Inicializar el mapa con valores aleatorios entre 1 y 10
	const map = Array.from({ length: height }, () => Array.from({ length: width }, getRandomValue));

	// Crear muros en los bordes y dejar espacio para una salida
	// for (let x = 0; x < width; x++) {
	// 	map[0][x] = 10; // Borde superior
	// 	map[height - 1][x] = 10; // Borde inferior
	// }
	// for (let y = 0; y < height; y++) {
	// 	map[y][0] = 10; // Borde izquierdo
	// 	map[y][width - 1] = 10; // Borde derecho
	// }

	// Agrupar obstáculos en bloques de 5x5
	function placeObstacles() {
		for (let y = 1; y < height - 5; y += 6) {
			// Saltar 5 filas cada vez
			for (let x = 1; x < width - 5; x += 6) {
				// Saltar 5 columnas cada vez
				// Crear un grupo de 5x5 obstáculos
				for (let dy = 0; dy < 5; dy++) {
					for (let dx = 0; dx < 5; dx++) {
						if (x + dx < width && y + dy < height) {
							map[y + dy][x + dx] = 10; // Establecer como obstáculo
						}
					}
				}
			}
		}
	}

	// Llamar a la función para agrupar obstáculos
	placeObstacles();

	// Función para verificar si una posición es válida
	function isValid(x, y) {
		return x > 0 && y > 0 && x < width - 1 && y < height - 1 && map[y][x] >= 1 && map[y][x] <= 10;
	}

	// Función recursiva para crear un camino usando DFS con caminos más amplios
	function createPath(x, y) {
		// Marcar un área de 2x2 como parte del camino (valor 0)
		for (let dx = 0; dx < 2; dx++) {
			for (let dy = 0; dy < 2; dy++) {
				if (x + dx < width && y + dy < height) {
					map[y + dy][x + dx] = 0;
				}
			}
		}

		// Direcciones de movimiento: arriba, abajo, izquierda, derecha
		const directions = [
			[0, -2],
			[0, 2],
			[-2, 0],
			[2, 0],
		];

		// Mezclar direcciones para generar caminos aleatorios
		directions.sort(() => Math.random() - 0.5);

		for (const [dx, dy] of directions) {
			const newX = x + dx;
			const newY = y + dy;

			// Crear camino solo si la posición es válida y al menos 2 de las 4 direcciones adyacentes están rodeadas de paredes
			if (isValid(newX, newY)) {
				let walls = 0;
				for (const [adx, ady] of directions) {
					const adjX = newX + adx;
					const adjY = newY + ady;
					if (
						adjX > 0 &&
						adjY > 0 &&
						adjX < width - 1 &&
						adjY < height - 1 &&
						map[adjY][adjX] <= 10 &&
						map[adjY][adjX] >= 1
					) {
						walls++;
					}
				}

				// Continuar si está rodeado de paredes por al menos 3 lados
				if (walls >= 2 || (newX === end.x && newY === end.y)) {
					createPath(newX, newY);
				}
			}
		}
	}

	createPath(start.x, start.y);

	// hardcoded: limpiar camino hacia el final
	map[start.y - 1][start.x] = 0;
	map[end.y][end.x - 1] = 0;
	map[end.y - 1][end.x - 1] = 0;
	map[end.y - 2][end.x - 1] = 0;

	const flattenedMap = map.flat();
	const lvl = {
		layers: [
			{
				opacity: 1,
				name: 'Tile Layer 1',
				width: width,
				data: flattenedMap,
				height: height,
				visible: true,
				y: 0,
				x: 0,
				type: 'tilelayer',
				id: 1,
			},
			{
				opacity: 1,
				name: 'Object Layer 1',
				visible: true,
				objects: [
					{
						name: 'start',
						width: 16,
						height: 16,
						visible: true,
						gid: 28,
						y: (start.y - 1) * 16,
						x: start.x * 16,
						rotation: 0,
						type: 'player',
						id: 1,
					},
					{
						name: 'end',
						width: 16,
						height: 16,
						visible: true,
						gid: 29,
						y: end.y * 16,
						x: end.x * 16,
						rotation: 0,
						type: 'goal',
						id: 2,
					},
				],
				draworder: 'topdown',
				y: 0,
				x: 0,
				type: 'objectgroup',
				id: 2,
			},
		],
		orientation: 'orthogonal',
		tileheight: 16,
		tiledversion: '1.2.4',
		tilewidth: 16,
		version: 1.2,
		height: height,
		width: width,
		renderorder: 'right-down',
		nextlayerid: 3,
		tilesets: [
			{
				source: 'tileset.tsx',
				firstgid: 1,
			},
		],
		infinite: false,
		type: 'map',
		nextobjectid: 4,
	};

	return lvl;
}
